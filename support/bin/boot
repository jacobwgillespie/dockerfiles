#!/bin/bash
#
# This script is designed to be run inside the container
#

# fail hard and fast even on pipelines
set -eo pipefail

# set debug based on envvar
[[ $DEBUG ]] && set -x

DIR=$(dirname $0)

# functions
. $DIR/functions

DB_OPTIONS="/etc/redis/redis.conf --logfile /var/log/redis.log"
PORT=${PUBLISH:-6379}
PROTO=${PROTO:-tcp}
ETCD_HOST=${ETCD_HOST:-$HOST}

if [[ -z $HOST ]]; then
  echo '==> $HOST not set.  Booting standalone redis.'
  echo "==> Running..."
  touch /var/log/redis.log
  tail -f /var/log/redis.log &
  redis-server $DB_OPTIONS
  exit $?
fi

configure_etcd

etcd_set_default host $HOST
etcd_set_default port $PORT

if [[ ! -z $CLUSTER ]]; then
  etcd_set_default cluster/name ${CLUSTER}
  etcd_set_default cluster/master ""
fi

cluster_master
cluster_members

echo Starting redis in HA mode

if [[ -z $CLUSTER_MASTER ]]; then
  # Perform Election
  echo "==> There is no current master - performing election..."
  etcdctl $ETCD_OPTIONS ls $ETCD_PATH/election >/dev/null 2>&1 || etcdctl $ETCD_OPTIONS mkdir $ETCD_PATH/election >/dev/null 2>&1
  if etcdctl $ETCD_OPTIONS mk $ETCD_PATH/election/bootstrap $HOSTNAME >/dev/null 2>&1; then
    echo "-----> Hurruh I win!  I'm the master"
    BOOTSTRAP=1
    export MASTER=1
    etcdctl $ETCD_OPTIONS set $ETCD_PATH/election/bootstrap $HOSTNAME --ttl 300 >/dev/null 2>&1
    redis-server $DB_OPTIONS &
  else
    echo -n "-----> I lost election.  Waiting for the master."
    until [[ ! -z $CLUSTER_MASTER ]]; do
      cluster_master
      echo -n "."
      sleep 10
    done
    echo "-----> Master ready - starting..."
    sleep 5
    echo "-----> Joining as slave: $CLUSTER_MASTER"
    redis-server $DB_OPTIONS --slaveof $CLUSTER_MASTER &
  fi
else
  cluster_master
  echo "-----> Joining with known master: $CLUSTER_MASTER"
  redis-server $DB_OPTIONS --slaveof $CLUSTER_MASTER &
fi

SERVICE_PID=$!

echo $SERVICE_PID > /app/redis.pid

# smart shutdown on SIGINT and SIGTERM
trap on_exit INT TERM

# wait for the service to become available
echo "==> Sleeping for 20 seconds, then testing if redis is up."
sleep 20
while [[ -z $(netstat -lnt | awk "\$6 == \"LISTEN\" && \$4 ~ \".$PUBLISH\" && \$1 ~ \"$PROTO.?\"") ]] ; do sleep 1; done

echo "==> Redis running..."

tail -f /var/log/redis.log &

# publish the service to etcd using the injected HOST and PORT
if [[ ! -z $PUBLISH ]]; then

  set +e

  # wait for the service to become available on PUBLISH port
  sleep 1 && while [[ -z $(netstat -lnt | awk "\$6 == \"LISTEN\" && \$4 ~ \".$PUBLISH\" && \$1 ~ \"$PROTO.?\"") ]] ; do sleep 1; done

  # while the port is listening, publish to etcd
  while [[ ! -z $(netstat -lnt | awk "\$6 == \"LISTEN\" && \$4 ~ \".$PUBLISH\" && \$1 ~ \"$PROTO.?\"") ]] ; do
    publish_to_etcd
    if [[ MASTER -eq "1" ]]; then
      publish_master_to_etcd
    fi
    sleep $(($ETCD_TTL/2)) # sleep for half the TTL
  done

  # if the loop quits, something went wrong
  exit 1

fi

wait
